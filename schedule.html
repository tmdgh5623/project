<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>월간 스케줄</title>
<style>
  /* ===== 전역 설정 ===== */
  :root{
    /* 요일/날짜/기타(빨간) 고정 높이(px) — 전 팀 동일 */
    --dow-h: 22px;    /* 요일줄 */
    --date-h: 22px;   /* 날짜 숫자줄 */
    --note-h: 28px;   /* 빨간 기타 메모줄 */
    --cell-pad: 4px 6px;
    --cell-font: 12px;
    --cell-line: 1.15;
  }

  html, body{
    height:100%; margin:0; overflow:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;
    color:#222; background:#fff;
  }

  /* 공통 상단바 (프로젝트 내 다른 페이지와 동일 스타일 가정) */
  .nav{
    background:#2c3e50; color:#fff; padding:10px;
    display:flex; justify-content:flex-end; gap:10px;
    position:sticky; top:0; z-index:1000;
  }
  .nav button{ background:#fff; color:#000; border:none; border-radius:4px; padding:6px 12px; cursor:pointer; }

  /* 페이지 상단 컨트롤 */
  #top-bar{
    background:#f7f7f8; border-bottom:1px solid #e5e7eb; padding:8px 14px;
    display:flex; align-items:center; gap:10px; position:sticky; top:0; z-index:900;
  }
  #top-bar h1{ margin:0; font-size:18px; }
  #top-bar select, #top-bar button{
    padding:5px 10px; font-size:14px; border:1px solid #dcdcdc; border-radius:8px; background:#fff;
  }
  #status{ color:#666; font-size:13px; margin-left:4px; }

  /* ===== 본문 영역 ===== */
  .page{
    height:calc(100vh - 96px); /* nav+top-bar 제외 */
    overflow:auto; padding:12px 14px 16px; box-sizing:border-box;
    scroll-snap-type:y mandatory;
  }

  /* 한 화면 = 한 팀 */
  .team{
    scroll-snap-align:start;
    border:1px solid #e5e7eb; border-radius:12px; background:#fff;
    box-shadow:0 1px 4px rgba(0,0,0,.04);
    display:flex; flex-direction:column;
    height:calc(100vh - 96px - 28px); /* 상단 패딩 여유 */
    margin-bottom:14px; overflow:hidden;
  }
  .teambar{ background:#e9eef5; border-bottom:1px solid #dbe2ea; color:#1f2937; font-size:12px; font-weight:700; padding:8px 12px; }

  .table-wrap{ flex:1 1 auto; overflow:hidden; }

  /* ===== 캘린더 표 ===== */
  table{
    width:100%; height:100%; table-layout:fixed; border-collapse:collapse;
  }
  td{
    border:1px solid #e6e6e6; padding:var(--cell-pad); vertical-align:top;
    font-size:var(--cell-font); line-height:var(--cell-line); box-sizing:border-box;
    overflow:hidden;
  }
  /* 모든 칸의 실제 콘텐츠 컨테이너 */
  td>.cell{ height:100%; overflow:hidden; }

  /* 고정 높이 줄들 */
  tr[data-dow="1"]{ height:var(--dow-h); background:#f3f4f6; }
  tr[data-dow="1"] td{ padding:0 4px; font-size:11px; font-weight:600; text-align:center; }
  tr[data-dow="1"] td .cell{ height:var(--dow-h); line-height:var(--dow-h); white-space:nowrap; text-overflow:ellipsis; }

  tr[data-date="1"]{ height:var(--date-h); }
  tr[data-date="1"] td{ padding:0 4px; text-align:center; font-weight:600; }
  tr[data-date="1"] td .cell{ height:var(--date-h); line-height:var(--date-h); white-space:nowrap; }

  /* 기타(빨간) 메모줄: 높이 고정 */
  tr[data-note="1"]{ height:var(--note-h); }

  /* 스케줄 줄(가변) — JS가 정확 픽셀을 계산해서 height 지정 */
  tr[data-sched="1"]{ }

  /* placeholder 행(빈 줄 채움) 배경 */
  tr.placeholder-sched td{ background:#fff; }
  tr.placeholder-note  td{ background:#fde8e8; } /* 연한 빨강 */
</style>
</head>
<body>
  <div class="nav" id="nav">
    <button onclick="location.href='index.html'">홈</button>
    <button onclick="location.href='monthly.html'">월별 대상처 리스트</button>
    <button onclick="location.href='map.html'">지도 보기</button>
    <button onclick="location.href='schedule.html'">스케줄</button>
  </div>

  <div id="top-bar">
    <h1>월간 스케줄</h1>
    <label for="sheetSelect"><strong>월 선택:</strong></label>
    <select id="sheetSelect"></select>
    <button id="refreshBtn">새로고침</button>
    <span id="status"></span>
  </div>

  <div class="page" id="page">
    <!-- 팀별 섹션이 JS로 들어옴 -->
  </div>

<script>
/* ============ 옵션 (필요시만 변경) ============ */
const SCHEDULE_ROWS_PER_WEEK = 4;    // 스케줄 줄(주당)
const NOTE_ROWS_PER_WEEK     = 1;    // 기타(빨간) 줄(주당)
const MIN_FONT_PX = 9;               // 줄 안 글자 최소 폰트
const API = (qs) => `/api/schedule${qs?('?' + qs):''}`;

/* ============ 엘리먼트 ============ */
const $page    = document.getElementById('page');
const $select  = document.getElementById('sheetSelect');
const $refresh = document.getElementById('refreshBtn');
const $status  = document.getElementById('status');

/* ============ 진입 ============ */
init().catch(showError);

async function init(){
  /* 시트 목록 (간단 캐시) */
  let sheets = null;
  try{
    const cached = JSON.parse(sessionStorage.getItem('sheets:v1')||'null');
    if (cached && Date.now()-cached.t < 5*60*1000) sheets = cached.list;
  }catch(_){}
  if (!sheets){
    const j = await getJson(API('mode=sheets'));
    sheets = j.sheets || [];
    sessionStorage.setItem('sheets:v1', JSON.stringify({t:Date.now(), list:sheets}));
  }

  const now = new Date();
  const initMonth = `${now.getMonth()+1}월`;

  $select.innerHTML = sheets.map(n => `<option value="${esc(n)}">${esc(n)}</option>`).join('');
  $select.value = sheets.includes(initMonth) ? initMonth : (sheets[0] || '1월');

  $select.addEventListener('change', () => render($select.value));
  $refresh.addEventListener('click', () => render($select.value));

  await render($select.value);
  window.addEventListener('resize', () => fixAllHeights());
}

/* ============ 렌더링 메인 ============ */
async function render(sheetName){
  setLoading(`${sheetName} 불러오는 중…`);
  const data = await getJson(API(new URLSearchParams({mode:'month', sheet:sheetName}).toString()));
  if (!data?.ok) throw new Error(data?.error || 'API 오류');

  $page.innerHTML = '';
  const year = data.year || (new Date()).getFullYear();

  for(const team of data.teams){
    $page.appendChild(renderTeam(team, {sheetName, year}));
  }

  // 구조 정규화(주당 4+1 고정) 후 높이 계산
  normalizeAllTables();
  fixAllHeights();
  clampAllCells();
  setLoading('');
}

/* ============ 팀 섹션 만들기 ============ */
function renderTeam(team, {sheetName, year}={}){
  const wrap = document.createElement('section'); wrap.className='team';
  const bar  = document.createElement('div'); bar.className='teambar'; bar.textContent = `${team.id}팀`;
  const tw   = document.createElement('div'); tw.className='table-wrap';
  const tbl  = document.createElement('table');

  // 스프레드시트에서 넘어온 그리드(병합 포함) 복원
  const grid = Array.from({length: team.rows}, () => Array(team.cols).fill(null));
  team.cells.forEach(cell=>{
    const r0 = cell.r-1, c0 = cell.c-1;
    grid[r0][c0] = cell;
    const rs = cell.rowspan||1, cs = cell.colspan||1;
    for(let r=r0;r<r0+rs;r++){
      for(let c=c0;c<c0+cs;c++){
        if (r===r0 && c===c0) continue;
        grid[r][c]='skip';
      }
    }
  });

  // 요일줄/날짜숫자줄 탐지
  const isDowRow = (row)=> {
    const KR=['일','월','화','수','목','금','토']; const EN=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    let hit=0,total=0;
    for (let c=0;c<team.cols;c++){
      const cell = row[c]; if(cell==='skip') continue; total++;
      const t = visibleText(cell);
      if (KR.some(x=>t.includes(x)) || EN.some(x=>t.includes(x))) hit++;
    }
    return total && hit >= Math.max(5, Math.floor(total*0.6));
  };
  const isDateNumRow = (row) => {
    let d=0,total=0;
    for(let c=0;c<team.cols;c++){
      const cell=row[c]; if(cell==='skip') continue; total++;
      const t = visibleText(cell);
      if (/^\d{1,2}$/.test(t)) d++;
    }
    return total && d >= Math.max(5, Math.floor(total*0.6));
  };

  for (let r=0;r<team.rows;r++){
    const tr = document.createElement('tr');

    if (r===0 && isDowRow(grid[r])) tr.dataset.dow = '1';
    if (isDateNumRow(grid[r]))      tr.dataset.date = '1';

    for (let c=0;c<team.cols;c++){
      const cell = grid[r][c];
      if (cell==='skip') continue;

      const td = document.createElement('td');

      if (cell){
        if (cell.rowspan>1) td.rowSpan = cell.rowspan;
        if (cell.colspan>1) td.colSpan = cell.colspan;
        if (cell.bg) td.style.backgroundColor = cell.bg;

        const t = visibleText(cell);
        if (cell.html && t !== '') td.innerHTML = cell.html;
        else { if (cell.fc) td.style.color = cell.fc; td.textContent = t; }
      }

      // .cell 보장
      let box = td.querySelector('.cell');
      if(!box){
        box=document.createElement('div'); box.className='cell';
        while(td.firstChild) box.appendChild(td.firstChild);
        td.appendChild(box);
      }
      tr.appendChild(td);
    }
    tbl.appendChild(tr);
  }

  tw.appendChild(tbl);
  wrap.appendChild(bar);
  wrap.appendChild(tw);
  return wrap;
}

/* ============ 구조 정규화 (주당 4 스케줄 + 1 기타 고정) ============ */
function normalizeAllTables(){
  document.querySelectorAll('.table-wrap table').forEach(tbl=>{
    const rows = ()=> Array.from(tbl.querySelectorAll('tr'));
    let arr = rows();

    // 첫 DateRow들을 찾아 주 시작 인덱스 수집
    const weekStarts = arr.map((tr,i)=> tr.dataset.date==='1' ? i : -1).filter(i=>i>=0);
    if (!weekStarts.length) return;

    // 기타(빨강) 줄 판정
    const isNoteRow = (tr)=>{
      const tds = Array.from(tr.querySelectorAll('td'));
      let red=0, span=0;
      tds.forEach(td=>{
        const s=td.colSpan||1; span+=s;
        const bg = getComputedStyle(td).backgroundColor || td.style.backgroundColor;
        if (isReddish(bg)) red+=s;
      });
      return span && (red/span)>=0.5;
    };

    const makeRow = (className)=>{
      const tr=document.createElement('tr'); if(className) tr.className=className;
      for(let i=0;i<7;i++){ // 7열 가정(스케줄표 형태)
        const td=document.createElement('td'); const box=document.createElement('div'); box.className='cell';
        td.appendChild(box); tr.appendChild(td);
      }
      return tr;
    };

    weekStarts.forEach((ws,idx)=>{
      arr = rows();
      const end = weekStarts[idx+1] ?? arr.length;
      const block = arr.slice(ws+1, end);

      let sched = block.filter(tr=> !isNoteRow(tr));
      let note  = block.filter(tr=>  isNoteRow(tr));

      // 스케줄 줄 과다 → 4번째 줄에 병합
      if (sched.length > SCHEDULE_ROWS_PER_WEEK){
        const keep = sched.slice(0, SCHEDULE_ROWS_PER_WEEK);
        for (let i=SCHEDULE_ROWS_PER_WEEK;i<sched.length;i++){
          mergeRowInto(sched[i], keep[SCHEDULE_ROWS_PER_WEEK-1]);
        }
      }

      // 부족 → 빈 스케줄 줄 추가
      arr = rows();
      const freshBlock = arr.slice(ws+1, end);
      let freshSched = freshBlock.filter(tr=> !isNoteRow(tr));
      let freshNote  = freshBlock.filter(tr=>  isNoteRow(tr));
      while (freshSched.length < SCHEDULE_ROWS_PER_WEEK){
        const tr = makeRow('placeholder-sched'); tr.dataset.sched='1';
        tbl.tBodies[0].insertBefore(tr, freshNote[0] || arr[end] || null);
        arr = rows();
        const fb = arr.slice(ws+1, end);
        freshSched = fb.filter(tr=> !isNoteRow(tr));
        freshNote  = fb.filter(tr=>  isNoteRow(tr));
      }

      // 노트는 정확히 1줄
      if (freshNote.length === 0){
        const tr = makeRow('placeholder-note'); tr.dataset.note='1';
        tbl.tBodies[0].insertBefore(tr, arr[end] || null);
      }else{
        freshNote[0].dataset.note='1';
        for (let i=1;i<freshNote.length;i++){
          mergeRowInto(freshNote[i], freshNote[0]);
        }
      }

      // 스케줄 줄 마킹
      arr = rows();
      const finalBlock = arr.slice(ws+1, end);
      finalBlock.filter(tr=> tr!==finalBlock.find(x=>x.dataset.note==='1'))
                .forEach(tr=> tr.dataset.sched='1');
    });
  });

  // 유틸: 한 줄을 다른 줄 뒤에 합치기
  function mergeRowInto(src, dst){
    const dT = dst.querySelectorAll('td');
    const sT = src.querySelectorAll('td');
    const n = Math.min(dT.length, sT.length);
    for (let j=0;j<n;j++){
      const dstBox = ensureCell(dT[j]);
      const srcBox = sT[j].querySelector('.cell') || sT[j];
      const html = srcBox.innerHTML.trim();
      if (html){
        const div=document.createElement('div'); div.className='it'; div.innerHTML=html;
        dstBox.appendChild(div);
      }
    }
    src.remove();
  }
}

/* ============ 높이 계산: 고정 줄 + 남은 영역 균등 분배 ============ */
function fixAllHeights(){
  document.querySelectorAll('.team .table-wrap').forEach(wrap=>{
    const tbl = wrap.querySelector('table'); if (!tbl) return;

    const rows = Array.from(tbl.querySelectorAll('tr'));
    const weekStarts = rows.map((tr,i)=> tr.dataset.date==='1' ? i : -1).filter(i=>i>=0);
    if (!weekStarts.length) return;

    const dowH   = parseFloat(getCss(tbl, '--dow-h'))  || 0;
    const dateH  = parseFloat(getCss(tbl, '--date-h')) || 0;
    const noteH  = parseFloat(getCss(tbl, '--note-h')) || 0;

    // 표 전체에서 고정 줄들의 합계
    const hasDow = rows[0]?.dataset.dow === '1';
    const headerFixed = (hasDow ? dowH : 0) + weekStarts.length * (dateH + noteH);

    const wrapH = wrap.clientHeight;
    const avail = Math.max(40, wrapH - headerFixed); // 스케줄 전체에 주는 높이
    const totalSchedRows = weekStarts.length * SCHEDULE_ROWS_PER_WEEK;
    const schedH = Math.floor(avail / Math.max(1,totalSchedRows));
    let leftover = avail - schedH * totalSchedRows; // 남는 픽셀을 앞쪽 행에 1px씩

    rows.forEach((tr,i)=>{
      if (tr.dataset.dow==='1'){ tr.style.height = `${dowH}px`; return; }
      if (tr.dataset.date==='1'){ tr.style.height = `${dateH}px`; return; }
      if (tr.dataset.note==='1'){ tr.style.height = `${noteH}px`; return; }
      if (tr.dataset.sched==='1'){
        const h = schedH + (leftover>0 ? 1 : 0);
        if (leftover>0) leftover--;
        tr.style.height = `${h}px`;
      }
      // 각 셀도 100% 채우도록
      tr.querySelectorAll('td').forEach(td=> td.style.height='100%');
      tr.querySelectorAll('.cell').forEach(c=> c.style.height='100%');
    });
  });

  // 글자 수축은 높이 계산 후
  clampAllCells();
}

/* ============ 텍스트 오버플로우 처리 (줄 수 제한) ============ */
function clampAllCells(){
  document.querySelectorAll('tr[data-sched="1"] td .cell, tr[data-note="1"] td .cell')
    .forEach(el => shrinkToFit(el, MIN_FONT_PX));
}

/* ============ 유틸들 ============ */
async function getJson(url){
  const r = await fetch(url, {cache:'no-store'});
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return r.json();
}
function setLoading(msg){ $status.textContent = msg || ''; }
function showError(e){ console.error(e); setLoading(`오류: ${e?.message || e}`); }

function esc(s){
  const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
  return String(s).replace(/[&<>"']/g, ch => map[ch]);
}
function visibleText(cell){
  if (cell?.html){
    return String(cell.html).replace(/<br\s*\/?>/gi,' ')
                            .replace(/&nbsp;/gi,' ')
                            .replace(/<[^>]*>/g,'')
                            .trim();
  }
  return String(cell?.text ?? '').trim();
}
function isReddish(c){
  if(!c) return false;
  c=String(c).trim().toLowerCase();
  if (c.startsWith('#')){
    if (c==='#f00' || c==='#ff0000') return true;
    if (c.length===7){
      const r=parseInt(c.slice(1,3),16), g=parseInt(c.slice(3,5),16), b=parseInt(c.slice(5,7),16);
      return (r>=200 && r>g && r>b);
    }
  }
  const m=c.match(/rgba?\((\d+)[,\s]+(\d+)[,\s]+(\d+)/);
  if (m){ const r=+m[1], g=+m[2], b=+m[3]; return (r>=200 && r>g && r>b); }
  return false;
}
function ensureCell(td){
  let box = td.querySelector('.cell');
  if(!box){ box=document.createElement('div'); box.className='cell';
    while(td.firstChild) box.appendChild(td.firstChild); td.appendChild(box); }
  return box;
}
function getCss(el, varName){
  const v = getComputedStyle(el).getPropertyValue(varName);
  return (v||'').replace('px','').trim();
}
function shrinkToFit(el, minPx){
  // 내용 없으면 스킵
  if (!el.textContent.trim() && el.children.length===0) return;
  // 초기화
  el.style.fontSize = '';
  el.style.lineHeight = '';
  let fs = parseFloat(getComputedStyle(el).fontSize) || 12;

  // 폰트 줄이기
  for (let i=0;i<10;i++){
    const fitsH = el.scrollHeight <= el.clientHeight;
    const fitsW = el.scrollWidth  <= el.clientWidth;
    if (fitsH && fitsW) break;
    fs = Math.max(minPx, Math.floor(fs * 0.92));
    el.style.fontSize  = fs + 'px';
    el.style.lineHeight = (0.95 + (fs - minPx) * 0.02).toFixed(2);
    if (fs <= minPx) break;
  }

  // 그래도 넘치면 line-clamp
  if (el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth){
    const cs = getComputedStyle(el);
    const lh = parseFloat(cs.lineHeight) || (parseFloat(cs.fontSize) * 1.15) || 12;
    const maxLines = Math.max(1, Math.floor(el.clientHeight / lh));
    el.style.display = '-webkit-box';
    el.style.webkitBoxOrient = 'vertical';
    el.style.webkitLineClamp = String(maxLines);
    el.style.overflow = 'hidden';
  }
}
</script>
</body>
</html>
