<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì¹´ì¹´ì˜¤ ì§€ë„ - ê³„ì•½ì²˜ ì ê²€</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    /* ì§€ë„ ë° ê¸°ë³¸ êµ¬ì¡° */
    #map { width: 100%; height: 90vh; }
    #main-container { display: flex; }
    #sidebar {
      width: 300px; max-height: 90vh;
      overflow-y: auto; background: #fff;
      border-right: 1px solid #ccc; padding: 10px;
    }
    #location-list { list-style: none; padding: 0; }

    /* ìƒë‹¨ í•„í„°ë°” */
    #filters {
      display: flex; flex-wrap: wrap;
      align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px; background: #f0f0f0;
    }
    .filter-group { display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
    #month-filter label { margin-right: 6px; white-space: nowrap; }
    #search {
      padding: 4px 8px; border: 1px solid #ccc;
      border-radius: 4px;
    }
    .label-overlay {
      background: white; border: 1px solid #888;
      padding: 2px 6px; font-size: 12px;
      pointer-events: none; white-space: nowrap;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.3); z-index: 11;
    }

    /* ë°˜ì‘í˜• ëª¨ë°”ì¼ ëŒ€ì‘ */
    @media (max-width: 768px) {
      html, body { margin: 0; padding: 0; height: 100vh; overflow: hidden; }
      #filters { max-height: 20vh; overflow-y: auto; flex-direction: column; align-items: flex-start; }
      #main-container { display: flex; flex-direction: column; height: calc(100vh - 10vh); }
      #sidebar {
        flex: 0 0 0; overflow-y: hidden;
        transition: flex-basis 0.3s ease;
        border-bottom: 1px solid #ccc; background: #fff;
      }
      #sidebar.open { flex: 0 0 10vh; overflow-y: auto; }
      #map { flex: 1 1 auto; min-height: 60vh; }
      #location-list { padding: 8px; font-size: 14px; }
      #search { width: 100%; max-width: 300px; }
    }
  </style>

  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=857fa34114fff62fa488d807a8666fcc&autoload=false&libraries=services,clusterer"></script>
</head>
<body>

<!-- âœ… ìƒë‹¨ë°” í•„í„° -->
<div id="filters">
  <div class="filter-group">
    <label><strong>ì›”:</strong></label>
    <div id="month-filter">
      <label><input type="checkbox" name="month" value="01" onchange="renderMarkers(); renderLocationList()">1ì›”</label>
      <label><input type="checkbox" name="month" value="02" onchange="renderMarkers(); renderLocationList()">2ì›”</label>
      <label><input type="checkbox" name="month" value="03" onchange="renderMarkers(); renderLocationList()">3ì›”</label>
      <label><input type="checkbox" name="month" value="04" onchange="renderMarkers(); renderLocationList()">4ì›”</label>
      <label><input type="checkbox" name="month" value="05" onchange="renderMarkers(); renderLocationList()">5ì›”</label>
      <label><input type="checkbox" name="month" value="06" onchange="renderMarkers(); renderLocationList()">6ì›”</label>
      <label><input type="checkbox" name="month" value="07" onchange="renderMarkers(); renderLocationList()">7ì›”</label>
      <label><input type="checkbox" name="month" value="08" onchange="renderMarkers(); renderLocationList()">8ì›”</label>
      <label><input type="checkbox" name="month" value="09" onchange="renderMarkers(); renderLocationList()">9ì›”</label>
      <label><input type="checkbox" name="month" value="10" onchange="renderMarkers(); renderLocationList()">10ì›”</label>
      <label><input type="checkbox" name="month" value="11" onchange="renderMarkers(); renderLocationList()">11ì›”</label>
      <label><input type="checkbox" name="month" value="12" onchange="renderMarkers(); renderLocationList()">12ì›”</label>
    </div>
  </div>

  <div class="filter-group">
    <label for="search-name"><strong>ğŸ“Œ ëŒ€ìƒì²˜ëª…:</strong></label>
    <input type="text" id="search-name" placeholder="ëŒ€ìƒì²˜ëª…ì„ ì…ë ¥">
    <label for="search-addr"><strong>ğŸ“ ì£¼ì†Œê²€ìƒ‰:</strong></label>
    <input type="text" id="search-addr" placeholder="ì£¼ì†Œ ì…ë ¥ í›„ Enter">
  </div>

  <div class="filter-group" style="margin-left:auto;">
    <button id="locate-me" style="padding:6px 12px; border:1px solid #ccc; border-radius:4px; background:white; cursor:pointer;">ğŸ“ ë‚´ ìœ„ì¹˜</button>
    <button id="toggle-list" style="padding:6px 12px; border:1px solid #ccc; border-radius:4px; background:white; cursor:pointer;">ğŸ“‹ ëª©ë¡ ë³´ê¸°</button>
    <b>ğŸ“Œ ë§ˆì»¤ ì„¤ëª…</b>
    <div style="display:flex; align-items:center; gap:8px;">
      <div><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSJub25lIi8+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iNyIgZmlsbD0iI0IyMjIyMiIvPjwvc3ZnPg==" width="16" height="16"> ì¢…í•©</div>
      <div><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSJub25lIi8+PHJlY3QgeD0iMTAiIHk9IjEwIiB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9IiNCMjIyMjIiLz48L3N2Zz4=" width="16" height="16"> ì‘ë™</div>
      <div><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBvbHlnb24gcG9pbnRzPSI4LDEzIDUsMyAxMSwzIiBmaWxsPSIjRkYwMDAwIi8+PC9zdmc+" width="16" height="16"> ì „ì²´</div>
    </div>
  </div>
</div>

<div id="main-container">
  <div id="sidebar">
    <h3 style="display:flex; justify-content:space-between; align-items:center;">
      ğŸ“Œ ëŒ€ìƒì²˜ ëª©ë¡
      <button id="uncheck-all" style="padding:4px 8px; font-size:12px; border:1px solid #ccc; border-radius:4px; background:white; cursor:pointer;">âŒ ì „ì²´ í•´ì œ</button>
    </h3>
    <ul id="location-list"></ul>
  </div>
  <div id="map" style="flex:1;"></div>
</div>

<script>
let map, geocoder, markers = [], openInfowindow = null, hoverLabel = null;
let checkedLocations = new Set();
let geocodedData = [], rawData = {}, labelOverlays = [], filteredData = [];
const geocodeCache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");

function saveCache() {
  localStorage.setItem("geocodeCache", JSON.stringify(geocodeCache));
}

async function geocodeWithCache(address, name) {
  const key = address + "_" + name;
  if (geocodeCache[key]) return geocodeCache[key];

  return new Promise(resolve => {
    geocoder.addressSearch(address, (result, status) => {
      if (status === kakao.maps.services.Status.OK) {
        const pos = { lat: parseFloat(result[0].y), lng: parseFloat(result[0].x) };
        geocodeCache[key] = pos;
        saveCache();
        resolve(pos);
      } else resolve(null);
    });
  });
}

kakao.maps.load(() => {
(async () => {
  map = new kakao.maps.Map(document.getElementById('map'), {
    center: new kakao.maps.LatLng(37.5665, 126.9780), level: 7
  });
  geocoder = new kakao.maps.services.Geocoder();
  kakao.maps.event.addListener(map, 'zoom_changed', updateLabelVisibility);

  const response = await fetch("https://script.google.com/macros/s/AKfycbw12xR7tz1fq1iQNbY-WIZUQ4C5wMFOE2vLr70ydsKNgdOx17t2iq3dnok0sjMgpVr_Ig/exec");
  rawData = await response.json();

// âœ… ê¸°ì¡´ ìºì‹œì— ìˆëŠ” ë°ì´í„°ëŠ” geocodedDataì— ë¨¼ì € ì¶”ê°€í•˜ê³ ,
// âœ… ìºì‹œì— ì—†ëŠ” ì£¼ì†Œë§Œ addressQueueì— ë„£ìŒ
const addressSet = new Set(), addressQueue = [];
for (const sheet in rawData) {
  for (const item of rawData[sheet]) {
    const roadAddr = item["ë„ë¡œëª…ì£¼ì†Œ"], jibunAddr = item["ì§€ë²ˆì£¼ì†Œ"];
    const address = roadAddr || jibunAddr;
    const name = item["ì›”ê´€ë¦¬ëŒ€ìƒì²˜"] || item["ë‹¨íƒ€ëŒ€ìƒì²˜"] || item["ê±°ë˜ì²˜ëª…"] || "ì´ë¦„ì—†ìŒ";
    if (!address || name.includes("ê³„ì•½í•´ì§€")) continue;
    const addressKey = address + "_" + name;
    if (addressSet.has(addressKey)) continue;
    addressSet.add(addressKey);

    if (geocodeCache[addressKey]) {
      // âœ… ì´ë¯¸ ìºì‹œì— ìˆìœ¼ë©´ ë°”ë¡œ geocodedDataì— ì¶”ê°€
      geocodedData.push({
        lat: geocodeCache[addressKey].lat,
        lng: geocodeCache[addressKey].lng,
        sheet, item
      });
    } else {
      // âœ… ìºì‹œì— ì—†ìœ¼ë©´ API í˜¸ì¶œ ëŒ€ìƒì— ì¶”ê°€
      addressQueue.push({ address, roadAddr, jibunAddr, sheet, item });
    }
  }
}

  const maxConcurrent = 5;
  let currentIndex = 0;
  async function processNextBatch() {
    const batch = addressQueue.slice(currentIndex, currentIndex + maxConcurrent);
    const promises = batch.map(async ({ roadAddr, jibunAddr, sheet, item }) => {
      const name = item["ì›”ê´€ë¦¬ëŒ€ìƒì²˜"] || item["ë‹¨íƒ€ëŒ€ìƒì²˜"] || item["ê±°ë˜ì²˜ëª…"] || "ì´ë¦„ì—†ìŒ";
      const addrList = [];
      if (roadAddr) addrList.push(roadAddr);
      if (jibunAddr) addrList.push(jibunAddr);

      let pos = null;
      for (const addr of addrList) {
        pos = await geocodeWithCache(addr, name);
        if (pos) break;
      }
      if (pos) geocodedData.push({ lat: pos.lat, lng: pos.lng, sheet, item });
    });
    await Promise.all(promises);
    currentIndex += maxConcurrent;
    if (currentIndex < addressQueue.length) {
      await new Promise(r => setTimeout(r, 100));
      await processNextBatch();
    }
  }
  await processNextBatch();

  geocodedData.forEach(({ sheet, item }) => {
    const key = getKey(sheet, item);
    if (!key.includes("ê³„ì•½í•´ì§€")) checkedLocations.add(key);
  });

  renderMarkers();
  renderLocationList();

  document.querySelectorAll('input[name="month"]').forEach(cb => {
    cb.addEventListener("change", () => {
      resetCheckedLocationsByMonth();
      renderMarkers();
      renderLocationList();
    });
  });
})();
});
function getSelectedMonths() {
  return Array.from(document.querySelectorAll('input[name="month"]:checked'))
    .map(cb => cb.value);
}

function getKey(sheet, item) {
  const ë²ˆí˜¸ = item["ë²ˆí˜¸"] || "";
  return `${sheet}_${ë²ˆí˜¸}`;
}

function getMarkerType(sheet, item, selectedMonths) {
  const ì¢…í•© = String(item["ì¢…í•©"] || "");
  const ì‘ë™ = String(item["ì‘ë™"] || "");
  if (!selectedMonths.length) return "ì „ì²´";
  for (const month of selectedMonths) {
    const regex = new RegExp(`\\b0?${month}\\b`);
    if (regex.test(ì¢…í•©)) return "ì¢…í•©";
    if (regex.test(ì‘ë™)) return "ì‘ë™";
  }
  return null;
}

function resetCheckedLocationsByMonth() {
  const selectedMonths = getSelectedMonths();
  const newChecked = new Set();
  geocodedData.forEach(({ sheet, item }) => {
    const key = getKey(sheet, item);
    if (key.includes("ê³„ì•½í•´ì§€")) return;
    const type = getMarkerType(sheet, item, selectedMonths);
    if (!selectedMonths.length || type !== null) newChecked.add(key);
  });
  checkedLocations = newChecked;
}

function getCustomMarkerIcon(type) {
  const size = new kakao.maps.Size(32, 32);
  const redCircle = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSJub25lIi8+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iNyIgZmlsbD0iI0IyMjIyMiIvPjwvc3ZnPg==";
  const redSquare = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSJub25lIi8+PHJlY3QgeD0iMTAiIHk9IjEwIiB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9IiNCMjIyMjIiLz48L3N2Zz4=";
  const triangle = "data:image/svg+xml;base64," + btoa('<svg width="32" height="32" xmlns="http://www.w3.org/2000/svg"><polygon points="16,24 10,10 22,10" fill="#FF0000"/></svg>');
  if (type === "ì¢…í•©") return new kakao.maps.MarkerImage(redCircle, size);
  if (type === "ì‘ë™") return new kakao.maps.MarkerImage(redSquare, size);
  return new kakao.maps.MarkerImage(triangle, size);
}

function renderMarkers() {
  labelOverlays.forEach(label => label.setMap(null));
  labelOverlays = [];
  if (openInfowindow) { openInfowindow.close(); openInfowindow = null; }
  markers.forEach(m => m.setMap(null));
  markers = [];

  const selectedMonths = getSelectedMonths();
  const search = document.getElementById("search-name").value.trim();
  const getName = (sheet, item) => item["ì›”ê´€ë¦¬ëŒ€ìƒì²˜"] || item["ë‹¨íƒ€ëŒ€ìƒì²˜"] || item["ê±°ë˜ì²˜ëª…"] || "ì´ë¦„ì—†ìŒ";

  const filtered = geocodedData.filter(({ sheet, item }) => {
    const name = getName(sheet, item);
    if (search && !name.includes(search)) return false;
    if (name.includes("ê³„ì•½í•´ì§€")) return false;
    const key = getKey(sheet, item);
    if (!checkedLocations.has(key)) return false;
    const type = getMarkerType(sheet, item, selectedMonths);
    return type !== null || checkedLocations.has(key);
  });

  filtered.forEach(({ lat, lng, sheet, item }) => {
    const name = getName(sheet, item);
    const ì—°ë½ì²˜ = Array.isArray(item["ì—°ë½ì²˜"]) ? item["ì—°ë½ì²˜"].join("\n") : (item["ì—°ë½ì²˜"] || "").toString();
    const ë¹„ê³  = Array.isArray(item["ë¹„ê³ "]) ? item["ë¹„ê³ "].join("\n") : (item["ë¹„ê³ "] || "").toString();
    const ê±´ë¬¼í˜„í™© = Array.isArray(item["ê±´ë¬¼í˜„í™©"]) ? item["ê±´ë¬¼í˜„í™©"].join("\n") : (item["ê±´ë¬¼í˜„í™©"] || "").toString();

    let type = getMarkerType(sheet, item, selectedMonths);
    if (!type) type = "ì „ì²´";

    const marker = new kakao.maps.Marker({
      position: new kakao.maps.LatLng(lat, lng), map,
      title: name, image: getCustomMarkerIcon(type), zIndex: 10
    });

    const nameLabel = new kakao.maps.CustomOverlay({
      position: marker.getPosition(),
      content: `<div style="padding:2px 6px;font-size:13px;font-weight:bold;color:black;white-space:nowrap;border-radius:4px;">${name}</div>`,
      yAnchor: 2.0, zIndex: 11
    });
    nameLabel.setMap(null);
    labelOverlays.push(nameLabel);

    const getValue = key => item[key]?.toString().split("T")[0] || "-";
    const ì¢…í•© = String(item["ì¢…í•©"] || ""), ì‘ë™ = String(item["ì‘ë™"] || "");
    const ì¢…í•©ì›”ë°°ì—´ = (ì¢…í•©.match(/\d+/g) || []).map(m => m.padStart(2, "0"));
    const ì‘ë™ì›”ë°°ì—´ = (ì‘ë™.match(/\d+/g) || []).map(m => m.padStart(2, "0"));
    const ì¢…í•©ì›”í…ìŠ¤íŠ¸ = ì¢…í•©ì›”ë°°ì—´.length ? ì¢…í•©ì›”ë°°ì—´.map(m => `${m}ì›”`).join(", ") : "";
    const ì‘ë™ì›”í…ìŠ¤íŠ¸ = ì‘ë™ì›”ë°°ì—´.length ? ì‘ë™ì›”ë°°ì—´.map(m => `${m}ì›”`).join(", ") : "";
    let ì ê²€í˜„í™© = "";
    ì ê²€í˜„í™© += ì¢…í•©ì›”í…ìŠ¤íŠ¸ ? `ì¢…í•© ${ì¢…í•©ì›”í…ìŠ¤íŠ¸}` : `ì¢…í•© -`;
    ì ê²€í˜„í™© += " ";
    ì ê²€í˜„í™© += ì‘ë™ì›”í…ìŠ¤íŠ¸ ? `ì‘ë™ ${ì‘ë™ì›”í…ìŠ¤íŠ¸}` : `ì‘ë™ -`;

    const types = [];
    if (!selectedMonths.length) {
      if (ì¢…í•©ì›”ë°°ì—´.length) types.push("ì¢…í•©");
      if (ì‘ë™ì›”ë°°ì—´.length) types.push("ì‘ë™");
    } else {
      if (selectedMonths.some(m => ì¢…í•©ì›”ë°°ì—´.includes(m))) types.push("ì¢…í•©");
      if (selectedMonths.some(m => ì‘ë™ì›”ë°°ì—´.includes(m))) types.push("ì‘ë™");
    }

    const content = `
      <div style="padding:10px 10px 20px;font-size:13px;line-height:1.6;max-width:320px;max-height:280px;overflow-y:auto;">
        <table style="border-spacing:0;width:100%;table-layout:fixed;">
          <tbody style="word-break:break-word;">
            <tr><td style="width:80px;text-align:right;padding-top:3px;"><b>ëŒ€ìƒì²˜ëª…</b></td><td style="padding-left:6px;">${name}</td></tr>
            <tr><td style="text-align:right;padding-top:3px;"><b>ê³„ì•½êµ¬ë¶„</b></td><td style="padding-left:6px;">${sheet}</td></tr>
            ${types.length ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì ê²€êµ¬ë¶„</b></td><td style="padding-left:6px;">${types.join(", ")}</td></tr>` : ""}
            ${item["ì£¼ìš©ë„"] ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì£¼ìš©ë„</b></td><td style="padding-left:6px;">${item["ì£¼ìš©ë„"]}</td></tr>` : ""}
            <tr><td style="text-align:right;padding-top:3px;"><b>ì ê²€í˜„í™©</b></td><td style="padding-left:6px;">${ì ê²€í˜„í™©}</td></tr>
            ${getValue("ì‚¬ìš©ìŠ¹ì¸ì›”") ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì‚¬ìš©ìŠ¹ì¸ì¼</b></td><td style="padding-left:6px;">${getValue("ì‚¬ìš©ìŠ¹ì¸ì›”")}</td></tr>` : ""}
            ${item["ë„ë¡œëª…ì£¼ì†Œ"] ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì£¼ì†Œ</b></td><td style="padding-left:6px;">${item["ë„ë¡œëª…ì£¼ì†Œ"]}</td></tr>` : ""}
            ${ì—°ë½ì²˜ ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì—°ë½ì²˜</b></td><td style="padding-left:6px;">${ì—°ë½ì²˜.replace(/\n/g, "<br>")}</td></tr>` : ""}
            ${item["ì—°ë©´ì ã¡"] ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì—°ë©´ì </b></td><td style="padding-left:6px;">${item["ì—°ë©´ì ã¡"]}</td></tr>` : ""}
            ${item["ì„¸ëŒ€"] ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì„¸ëŒ€</b></td><td style="padding-left:6px;">${item["ì„¸ëŒ€"]}ì„¸ëŒ€</td></tr>` : ""}
            ${item["ì„¸ëŒ€ì ê²€ëŒ€ìƒ"] ? `<tr><td style="text-align:right;padding-top:3px;"><b>ì„¸ëŒ€ì ê²€</b></td><td style="padding-left:6px;">${item["ì„¸ëŒ€ì ê²€ëŒ€ìƒ"]}</td></tr>` : ""}
            <tr><td style="text-align:right;padding-top:3px;"><b>ì„¤ë¹„</b></td><td style="padding-left:6px;">ì˜¥ë‚´:${item["ì˜¥ë‚´"] || "-"}, SP:${item["S/P"] || "-"}, ê°€ìŠ¤:${item["ê°€ìŠ¤"] || "-"}</td></tr>
            ${ê±´ë¬¼í˜„í™© ? `<tr><td style="text-align:right;padding-top:3px;"><b>ê±´ë¬¼í˜„í™©</b></td><td style="padding-left:6px;">${ê±´ë¬¼í˜„í™©.replace(/\n/g, "<br>")}</td></tr>` : ""}
            ${ë¹„ê³  ? `<tr><td style="text-align:right;padding-top:3px;"><b>ë¹„ê³ </b></td><td style="padding-left:6px;">${ë¹„ê³ .replace(/\n/g, "<br>")}</td></tr>` : ""}
          </tbody>
        </table>
      </div>`;

    const infowindow = new kakao.maps.InfoWindow({ content, zIndex: 9999 });

    kakao.maps.event.addListener(marker, 'click', () => {
      if (openInfowindow && openInfowindow.getContent() === infowindow.getContent()) {
        openInfowindow.close();
        openInfowindow = null;
      } else {
        if (openInfowindow) openInfowindow.close();
        infowindow.open(map, marker);
        const latlng = marker.getPosition();
        const proj = map.getProjection();
        const point = proj.containerPointFromCoords(latlng);
        point.y -= 100;
        map.setCenter(proj.coordsFromContainerPoint(point));
        openInfowindow = infowindow;
      }
    });

    kakao.maps.event.addListener(marker, 'mouseover', () => {
      if (hoverLabel) hoverLabel.setMap(null);
      hoverLabel = new kakao.maps.CustomOverlay({
        position: marker.getPosition(),
        content: `<div class="label-overlay">${name}</div>`,
        yAnchor: 2.0, zIndex: 12
      });
      hoverLabel.setMap(map);
    });

    kakao.maps.event.addListener(marker, 'mouseout', () => {
      if (hoverLabel) hoverLabel.setMap(null);
    });

    markers.push(marker);
  });

  updateLabelVisibility();
  filteredData = filtered;
}

function updateLabelVisibility() {
  const show = map.getLevel() <= 7;
  labelOverlays.forEach(label => {
    label.setMap(show ? map : null);
  });
}
function renderLocationList() {
  const search = document.getElementById("search-name").value.trim();
  const listEl = document.getElementById("location-list");
  listEl.innerHTML = "";

  const selectedMonths = getSelectedMonths();
  const getName = (sheet, item) => item["ì›”ê´€ë¦¬ëŒ€ìƒì²˜"] || item["ë‹¨íƒ€ëŒ€ìƒì²˜"] || item["ê±°ë˜ì²˜ëª…"] || "ì´ë¦„ì—†ìŒ";

  const sortedData = [...geocodedData].sort((a, b) => {
    const aName = getName(a.sheet, a.item);
    const bName = getName(b.sheet, b.item);
    const aType = getMarkerType(a.sheet, a.item, selectedMonths) !== null ? 0 : 1;
    const bType = getMarkerType(b.sheet, b.item, selectedMonths) !== null ? 0 : 1;
    if (aType !== bType) return aType - bType;
    return aName.localeCompare(bName, 'ko');
  });

  sortedData.forEach(({ lat, lng, sheet, item }) => {
    const name = getName(sheet, item);
    if (name.includes("ê³„ì•½í•´ì§€")) return;
    if (search && !name.includes(search)) return;

    const markerType = getMarkerType(sheet, item, selectedMonths);
    const listItem = document.createElement("li");
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.gap = "6px";
    listItem.style.padding = "6px 0";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    const key = getKey(sheet, item);
    checkbox.checked = checkedLocations.has(key);
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) checkedLocations.add(key);
      else checkedLocations.delete(key);
      renderMarkers();
    });

    const label = document.createElement("span");
    label.textContent = name;
    label.style.cursor = "pointer";
    label.onclick = () => {
      map.setCenter(new kakao.maps.LatLng(lat, lng));
      map.setLevel(4);
    };

    listItem.appendChild(checkbox);
    listItem.appendChild(label);
    listEl.appendChild(listItem);
  });
}

let myLocationMarker = null;
document.getElementById("locate-me").addEventListener("click", () => {
  if (!navigator.geolocation) { alert("í˜„ì¬ ë¸Œë¼ìš°ì €ì—ì„œ ìœ„ì¹˜ ì •ë³´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
  navigator.geolocation.getCurrentPosition(position => {
    const lat = position.coords.latitude;
    const lng = position.coords.longitude;
    const locPosition = new kakao.maps.LatLng(lat, lng);
    const blueCircleIcon = new kakao.maps.MarkerImage(
      "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><circle cx="16" cy="16" r="10" fill="#007BFF"/></svg>`),
      new kakao.maps.Size(32, 32)
    );
    if (myLocationMarker) myLocationMarker.setMap(null);
    myLocationMarker = new kakao.maps.Marker({ position: locPosition, map, title: "ë‚´ ìœ„ì¹˜", image: blueCircleIcon });
    map.setCenter(locPosition);
    map.setLevel(4);
  }, () => alert("ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."));
});

function searchAddress() {
  const address = document.getElementById("search-addr").value.trim();
  if (!address) return;
  const geocoder = new kakao.maps.services.Geocoder();
  geocoder.addressSearch(address, (result, status) => {
    if (status === kakao.maps.services.Status.OK) {
      const { y: lat, x: lng } = result[0];
      const moveLatLng = new kakao.maps.LatLng(lat, lng);
      map.setCenter(moveLatLng);
      map.setLevel(3);
      const marker = new kakao.maps.Marker({
        map, position: moveLatLng, title: "ê²€ìƒ‰ëœ ì£¼ì†Œ", zIndex: 1,
        image: new kakao.maps.MarkerImage(
          "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><circle cx="16" cy="16" r="10" fill="#008000"/></svg>`),
          new kakao.maps.Size(32, 32)
        )
      });
      if (window.searchMarker) window.searchMarker.setMap(null);
      window.searchMarker = marker;
    } else alert("ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  });
}

const toggleBtn = document.getElementById("toggle-list");
const sidebar = document.getElementById("sidebar");
toggleBtn.addEventListener("click", () => {
  sidebar.classList.toggle("open");
  toggleBtn.textContent = sidebar.classList.contains("open") ? "ğŸ“‹ ëª©ë¡ ë‹«ê¸°" : "ğŸ“‹ ëª©ë¡ ë³´ê¸°";
  setTimeout(() => { kakao.maps.event.trigger(map, 'resize'); }, 300);
});

document.getElementById("uncheck-all").addEventListener("click", () => {
  const allKeys = new Set();
  geocodedData.forEach(({ sheet, item }) => {
    const key = getKey(sheet, item);
    if (!key.includes("ê³„ì•½í•´ì§€")) allKeys.add(key);
  });
  const isAllChecked = checkedLocations.size === allKeys.size && [...allKeys].every(key => checkedLocations.has(key));
  if (isAllChecked) { checkedLocations.clear(); document.getElementById("uncheck-all").textContent = "âœ… ì „ì²´ ì„ íƒ"; }
  else { checkedLocations = new Set(allKeys); document.getElementById("uncheck-all").textContent = "âŒ ì „ì²´ í•´ì œ"; }
  renderLocationList(); renderMarkers();
});

document.getElementById("search-addr").addEventListener("input", () => {
  if (!document.getElementById("search-addr").value.trim() && window.searchMarker) {
    window.searchMarker.setMap(null); window.searchMarker = null;
  }
});
document.getElementById("search-name").addEventListener("input", () => {
  renderMarkers(); renderLocationList();
});
document.getElementById("search-addr").addEventListener("keydown", e => {
  if (e.key === "Enter") searchAddress();
});

window.renderMarkers = renderMarkers;
window.renderLocationList = renderLocationList;

</script>
</body>
</html>
